package body Dangler is

	--This function is what actually allows us to get the dangling reference. That is because of 3.10.2-10.1/3, which expressly allows this. I beleive this rule was intended to remain orthogonal with value type semantics, however a value type would be copied repeatedly throughout this, preventing a dangle.
	--I agree with Randy of R.R. that this should be a bug. However I disagree with him that this isn't valid Ada, as the rule is very easy to find in 3.10.2.
	function Inner(Value : aliased in out Integer) return Integer_Access is
	begin
		return Value'Access; --All we're doing here is immediately getting an access to Value. Wrapping this up in a function changes which accessability rule applies, and is therefore what allows the access to escape, and therefore dangle.
	end Inner;

	function Dangle return Integer_Access is
		Value : aliased Integer := 42; --This is the value we will reference, so wherever the address of this value is, we have a reference to.
	begin
		return Inner(Value); --All we're doing here is calling Inner with the function-scoped Value, and immediately returning whatever Inner returns, which happens to be the now escaped reference. This is also legal because of 3.10.2-10.1/3.
	end Dangle;

end Dangler;